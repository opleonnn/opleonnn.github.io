<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Swift 中的派发机制 - Leon</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Swift 中的派发机制"><meta itemprop=description content="本文探讨一下 Swift 中的方法调度。
1. 派发机制 函数派发(Method Dispatch)又名方法调度，简单讲就是编程语言在源代码中判断用哪种方式调用函数的机制。一般来讲方法派发的方式分为两种：
 静态派发 动态派发  静态派发(Static Dispatch) 又被称为直接派发，系统直接按照方法的具体实现地址进行调用，在编译期间就确定了调用的方法的具体实现。甚至编译器能够进行内联优化，因此，当调用该方法时，调用的指令集非常少，执行速度快，但相应的缺点也很明显，没有动态性。我们常见的C语言就使用直接派发、C++默认也使用直接派发。
动态派发(Dynamic Dispatch) 动态派发是指需要在运行时选择方法的具体实现。动态调度是多态的具体实现过程，被广泛的应用于 OOP 语言(object-oriented programing)中。一般实现动态派发的方式有两种，函数表派发和消息派发。
函数表派发 函数表派发是动态派发最常见的一种实现方式。每个类中会存在一个函数表，存储了每个函数实现的指针。当调用方法时，先找到类的函数表，然后再函数表中找到要调用的方法指针，最后根据该指针找到方法的具体实现。C++、Java 等语言就是通过函数表的方式来实现多态。
消息派发 方法调用就是给对象发送消息。以 Objective-C 举例， 调用方法需要在相应的类中遍历其方法列表，如果能找到相匹配的方法就调用该方法的实现，如果找不到，就沿着继承链的顺序继续向上查找。
2. SIL SIL 是 Swift 编译器中间语言，通过 swiftc 将 Swift 转化为 SIL 可以方便的查看 Swift 的方法派发方式。通过 SIL 文档中对动态调度的描述，我们可以查看动态调度所用的指令。这里简单总结下判断方法是动态调度还是静态调度的方式：
 class_method 和 super_method 使用 vtable 派发 witness_method 使用 witness_table 派发(Swift 协议中函数表派发的实现) objc_method 和 objc_super_method 使用 Objective-C message 派发，并使用 foreign 标记 其他诸如 function_ref 等指令使用的是静态派发  3. Swift 中的派发方式 Swift 中支持静态派发、函数表派发和消息派发三种派发方式，而派发方式主要与以下四点有关"><meta itemprop=datePublished content="2021-01-08T14:30:41+08:00"><meta itemprop=dateModified content="2021-01-08T14:30:41+08:00"><meta itemprop=wordCount content="1271"><meta itemprop=keywords content><meta property="og:title" content="Swift 中的派发机制"><meta property="og:description" content="本文探讨一下 Swift 中的方法调度。
1. 派发机制 函数派发(Method Dispatch)又名方法调度，简单讲就是编程语言在源代码中判断用哪种方式调用函数的机制。一般来讲方法派发的方式分为两种：
 静态派发 动态派发  静态派发(Static Dispatch) 又被称为直接派发，系统直接按照方法的具体实现地址进行调用，在编译期间就确定了调用的方法的具体实现。甚至编译器能够进行内联优化，因此，当调用该方法时，调用的指令集非常少，执行速度快，但相应的缺点也很明显，没有动态性。我们常见的C语言就使用直接派发、C++默认也使用直接派发。
动态派发(Dynamic Dispatch) 动态派发是指需要在运行时选择方法的具体实现。动态调度是多态的具体实现过程，被广泛的应用于 OOP 语言(object-oriented programing)中。一般实现动态派发的方式有两种，函数表派发和消息派发。
函数表派发 函数表派发是动态派发最常见的一种实现方式。每个类中会存在一个函数表，存储了每个函数实现的指针。当调用方法时，先找到类的函数表，然后再函数表中找到要调用的方法指针，最后根据该指针找到方法的具体实现。C++、Java 等语言就是通过函数表的方式来实现多态。
消息派发 方法调用就是给对象发送消息。以 Objective-C 举例， 调用方法需要在相应的类中遍历其方法列表，如果能找到相匹配的方法就调用该方法的实现，如果找不到，就沿着继承链的顺序继续向上查找。
2. SIL SIL 是 Swift 编译器中间语言，通过 swiftc 将 Swift 转化为 SIL 可以方便的查看 Swift 的方法派发方式。通过 SIL 文档中对动态调度的描述，我们可以查看动态调度所用的指令。这里简单总结下判断方法是动态调度还是静态调度的方式：
 class_method 和 super_method 使用 vtable 派发 witness_method 使用 witness_table 派发(Swift 协议中函数表派发的实现) objc_method 和 objc_super_method 使用 Objective-C message 派发，并使用 foreign 标记 其他诸如 function_ref 等指令使用的是静态派发  3. Swift 中的派发方式 Swift 中支持静态派发、函数表派发和消息派发三种派发方式，而派发方式主要与以下四点有关"><meta property="og:type" content="article"><meta property="og:url" content="https://opleonnn.github.io/posts/swift-dispatch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-08T14:30:41+08:00"><meta property="article:modified_time" content="2021-01-08T14:30:41+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Swift 中的派发机制"><meta name=twitter:description content="本文探讨一下 Swift 中的方法调度。
1. 派发机制 函数派发(Method Dispatch)又名方法调度，简单讲就是编程语言在源代码中判断用哪种方式调用函数的机制。一般来讲方法派发的方式分为两种：
 静态派发 动态派发  静态派发(Static Dispatch) 又被称为直接派发，系统直接按照方法的具体实现地址进行调用，在编译期间就确定了调用的方法的具体实现。甚至编译器能够进行内联优化，因此，当调用该方法时，调用的指令集非常少，执行速度快，但相应的缺点也很明显，没有动态性。我们常见的C语言就使用直接派发、C++默认也使用直接派发。
动态派发(Dynamic Dispatch) 动态派发是指需要在运行时选择方法的具体实现。动态调度是多态的具体实现过程，被广泛的应用于 OOP 语言(object-oriented programing)中。一般实现动态派发的方式有两种，函数表派发和消息派发。
函数表派发 函数表派发是动态派发最常见的一种实现方式。每个类中会存在一个函数表，存储了每个函数实现的指针。当调用方法时，先找到类的函数表，然后再函数表中找到要调用的方法指针，最后根据该指针找到方法的具体实现。C++、Java 等语言就是通过函数表的方式来实现多态。
消息派发 方法调用就是给对象发送消息。以 Objective-C 举例， 调用方法需要在相应的类中遍历其方法列表，如果能找到相匹配的方法就调用该方法的实现，如果找不到，就沿着继承链的顺序继续向上查找。
2. SIL SIL 是 Swift 编译器中间语言，通过 swiftc 将 Swift 转化为 SIL 可以方便的查看 Swift 的方法派发方式。通过 SIL 文档中对动态调度的描述，我们可以查看动态调度所用的指令。这里简单总结下判断方法是动态调度还是静态调度的方式：
 class_method 和 super_method 使用 vtable 派发 witness_method 使用 witness_table 派发(Swift 协议中函数表派发的实现) objc_method 和 objc_super_method 使用 Objective-C message 派发，并使用 foreign 标记 其他诸如 function_ref 等指令使用的是静态派发  3. Swift 中的派发方式 Swift 中支持静态派发、函数表派发和消息派发三种派发方式，而派发方式主要与以下四点有关"><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://opleonnn.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://opleonnn.github.io/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://opleonnn.github.io/css/dark.css><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://opleonnn.github.io/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://opleonnn.github.io/><img src="https://avatars0.githubusercontent.com/u/48051254?s=460&u=09cd38c785b674756a705c9958cfc5c0245c6936&v=4" alt=Leon></a></div><h1 class=site-title><a href=https://opleonnn.github.io/>Leon</a></h1><div class=site-description><p>学无止境</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/opleonnn title=Github><i data-feather=github></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>主页</a></li><li><a href=/posts>文章</a></li><li><a href=/about>关于</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>08</span>
<span class=rest>Jan 2021</span></div></div><div class=matter><h1 class=title>Swift 中的派发机制</h1></div></div><div class=markdown><p>本文探讨一下 Swift 中的方法调度。</p><h2 id=1-派发机制>1. 派发机制</h2><p>函数派发(Method Dispatch)又名方法调度，简单讲就是编程语言在源代码中判断用哪种方式调用函数的机制。一般来讲方法派发的方式分为两种：</p><ul><li>静态派发</li><li>动态派发</li></ul><h3 id=静态派发static-dispatchhttpsenwikipediaorgwikistatic_dispatch>静态派发(<a href=https://en.wikipedia.org/wiki/Static_dispatch>Static Dispatch</a>)</h3><p>又被称为直接派发，系统直接按照方法的具体实现地址进行调用，在编译期间就确定了调用的方法的具体实现。甚至编译器能够进行内联优化，因此，当调用该方法时，调用的指令集非常少，执行速度快，但相应的缺点也很明显，没有动态性。我们常见的C语言就使用直接派发、C++默认也使用直接派发。</p><h3 id=动态派发dynamic-dispatchhttpsenwikipediaorgwikidynamic_dispatch>动态派发(<a href=https://en.wikipedia.org/wiki/Dynamic_dispatch>Dynamic Dispatch</a>)</h3><p>动态派发是指需要在运行时选择方法的具体实现。动态调度是多态的具体实现过程，被广泛的应用于 OOP 语言(object-oriented programing)中。一般实现动态派发的方式有两种，函数表派发和消息派发。</p><h4 id=函数表派发>函数表派发</h4><p>函数表派发是动态派发最常见的一种实现方式。每个类中会存在一个函数表，存储了每个函数实现的指针。当调用方法时，先找到类的函数表，然后再函数表中找到要调用的方法指针，最后根据该指针找到方法的具体实现。C++、Java 等语言就是通过函数表的方式来实现多态。</p><h4 id=消息派发>消息派发</h4><p>方法调用就是给对象发送消息。以 Objective-C 举例， 调用方法需要在相应的类中遍历其方法列表，如果能找到相匹配的方法就调用该方法的实现，如果找不到，就沿着继承链的顺序继续向上查找。</p><h2 id=2-sil>2. SIL</h2><p><a href=https://github.com/apple/swift/blob/main/docs/SIL.rst>SIL</a> 是 Swift 编译器中间语言，通过 <code>swiftc</code> 将 Swift 转化为 SIL 可以方便的查看 Swift 的方法派发方式。通过 SIL 文档中对<a href=https://github.com/apple/swift/blob/main/docs/SIL.rst#dynamic-dispatch>动态调度</a>的描述，我们可以查看动态调度所用的指令。这里简单总结下判断方法是动态调度还是静态调度的方式：</p><ul><li><code>class_method</code> 和 <code>super_method</code> 使用 <code>vtable</code> 派发</li><li><code>witness_method</code> 使用 <code>witness_table</code> 派发(Swift 协议中函数表派发的实现)</li><li><code>objc_method</code> 和 <code>objc_super_method</code> 使用 <code>Objective-C message</code> 派发，并使用 <code>foreign</code> 标记</li><li>其他诸如 <code>function_ref</code> 等指令使用的是静态派发</li></ul><h2 id=3-swift-中的派发方式>3. Swift 中的派发方式</h2><p>Swift 中支持静态派发、函数表派发和消息派发三种派发方式，而派发方式主要与以下四点有关</p><ul><li>数据类型</li><li>声明位置</li><li>指定派发方式</li><li>编译器优化</li></ul><h3 id=31-数据类型>3.1 数据类型</h3><h4 id=值类型>值类型</h4><p>先来分析一下 Swift 结构体中的函数派发方式</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#00f>struct</span> <span style=color:#2b91af>MyStruct</span> {
    <span style=color:#00f>func</span> myMethod() {}
}

<span style=color:#00f>let</span> myStruct = MyStruct()
myStruct.myMethod()
</code></pre></div><p>利用 swiftc 将上述代码转换成 SIL，命令为 <code>swiftc -emit-silgen main.swift > main.sil</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// 截取 myStruct 的创建和调用 myMethod 方法部分</span>
<span style=color:green>// function_ref MyStruct.init()</span>
%5 = function_ref @<span>$</span>s4main8MyStructVACycfC : <span>$</span>@convention(method) (@thin MyStruct.<span style=color:#00f>Type</span>) -&gt; MyStruct <span style=color:green>// user: %6</span>
%6 = apply %5(%4) : <span>$</span>@convention(method) (@thin MyStruct.<span style=color:#00f>Type</span>) -&gt; MyStruct <span style=color:green>// user: %7</span>
store %6 to [trivial] %3 : <span>$</span>*MyStruct           <span style=color:green>// id: %7</span>
%8 = load [trivial] %3 : <span>$</span>*MyStruct             <span style=color:green>// user: %10</span>
<span style=color:green>// function_ref MyStruct.myMethod()</span>
%9 = function_ref @<span>$</span>s4main8MyStructV8myMethodyyF : <span>$</span>@convention(method) (MyStruct) -&gt; () <span style=color:green>// user: %10</span>
%10 = apply %9(%8) : <span>$</span>@convention(method) (MyStruct) -&gt; ()
</code></pre></div><p>从上述代码中我们可以看到在调用了 <code>MyStruct.init()</code> 方法后，直接调用了 <code>MyStruct.myMethod()</code>，同时调用该方法前使用了 <code>function_ref</code> 指令，使用的是静态派发。利用同样的方法，我们可以验证 enum 中的方法同样使用静态调度。因此我们可以得出结论，Swift 中值类型的方法采用静态派发。</p><h4 id=引用类型>引用类型</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#00f>class</span> <span style=color:#2b91af>MyClass</span> {
    <span style=color:#00f>func</span> myMethod() {}
}

<span style=color:#00f>let</span> myClass = MyClass()
myClass.myMethod()
</code></pre></div><p>转换成 SIL 后，我们查看以下关键代码</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// main</span>
sil @main : <span>$</span>@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {
bb0(%0 : <span>$</span>Int32, %1 : <span>$</span>UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):
  <span style=color:green>// 省略无关代码...</span>
  %9 = class_method %8 : <span>$</span>MyClass, #MyClass.myMethod : (MyClass) -&gt; () -&gt; (), <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; () <span style=color:green>// user: %10</span>
  %10 = apply %9(%8) : <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; ()
  <span style=color:green>// 省略无关代码...</span>
} <span style=color:green>// end sil function &#39;main&#39;</span>

<span style=color:green>// ...</span>
<span style=color:green>// 省略无关代码...</span>
<span style=color:green>// ...</span>

sil_vtable MyClass {
  #MyClass.myMethod: (MyClass) -&gt; () -&gt; () : @<span>$</span>s4main7MyClassC8myMethodyyF	<span style=color:green>// MyClass.myMethod()</span>
  <span style=color:green>// 省略无关代码...</span>
}
</code></pre></div><p>我们可以看到 <code>MyClass.myMethod</code> 方法出现在了 MyClass 的 <code>sil_vtable</code> 表中，同时调用 MyClass 中的 <code>myMethod</code> 方法前使用的指令为 <code>class_method</code>，根据 <a href=https://github.com/apple/swift/blob/main/docs/SIL.rst#dynamic-dispatch>SIL 文档</a> 解释，此处使用的是 <code>vtable dispatch</code>(函数表派发)。</p><h4 id=协议>协议</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#00f>protocol</span> <span style=color:#2b91af>MyProtocol</span> {
    <span style=color:#00f>func</span> myMethod()
}

<span style=color:#00f>class</span> <span style=color:#2b91af>MyClass</span>: MyProtocol {
    <span style=color:#00f>func</span> myMethod() {}
}

<span style=color:#00f>let</span> myProtocol: MyProtocol = MyClass()
myProtocol.myMethod()
</code></pre></div><p>转换成 SIL</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// main</span>
sil [ossa] @main : <span>$</span>@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {
bb0(%0 : <span>$</span>Int32, %1 : <span>$</span>UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):
  <span style=color:green>// 省略无关代码...</span>
  %10 = witness_method <span>$</span>@opened(<span style=color:#a31515>&#34;1C1A86E8-E2F3-11EB-B18F-ACDE48001122&#34;</span>) MyProtocol, #MyProtocol.myMethod : &lt;<span style=color:#00f>Self</span> <span style=color:#00f>where</span> <span style=color:#00f>Self</span> : MyProtocol&gt; (<span style=color:#00f>Self</span>) -&gt; () -&gt; (), %9 : <span>$</span>*@opened(<span style=color:#a31515>&#34;1C1A86E8-E2F3-11EB-B18F-ACDE48001122&#34;</span>) MyProtocol : <span>$</span>@convention(witness_method: MyProtocol) &lt;<span>τ</span>_0_0 <span style=color:#00f>where</span> <span>τ</span>_0_0 : MyProtocol&gt; (@in_guaranteed <span>τ</span>_0_0) -&gt; () <span style=color:green>// type-defs: %9; user: %11</span>
  %11 = apply %10&lt;@opened(<span style=color:#a31515>&#34;1C1A86E8-E2F3-11EB-B18F-ACDE48001122&#34;</span>) MyProtocol&gt;(%9) : <span>$</span>@convention(witness_method: MyProtocol) &lt;<span>τ</span>_0_0 <span style=color:#00f>where</span> <span>τ</span>_0_0 : MyProtocol&gt; (@in_guaranteed <span>τ</span>_0_0) -&gt; () <span style=color:green>// type-defs: %9</span>
  <span style=color:green>// 省略无关代码...</span>
} <span style=color:green>// end sil function &#39;main&#39;</span>

<span style=color:green>// protocol witness for MyProtocol.myMethod() in conformance MyClass</span>
sil <span style=color:#00f>private</span> [transparent] [thunk] [ossa] @<span>$</span>s4main7MyClassCAA0B8ProtocolA2aDP8myMethodyyFTW : <span>$</span>@convention(witness_method: MyProtocol) (@in_guaranteed MyClass) -&gt; () {
<span style=color:green>// %0                                             // user: %1</span>
bb0(%0 : <span>$</span>*MyClass):
  %1 = load_borrow %0 : <span>$</span>*MyClass                 <span style=color:green>// users: %5, %3, %2</span>
  %2 = class_method %1 : <span>$</span>MyClass, #MyClass.myMethod : (MyClass) -&gt; () -&gt; (), <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; () <span style=color:green>// user: %3</span>
  %3 = apply %2(%1) : <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; ()
  %4 = tuple ()                                   <span style=color:green>// user: %6</span>
  end_borrow %1 : <span>$</span>MyClass                        <span style=color:green>// id: %5</span>
  <span style=color:#00f>return</span> %4 : <span>$</span>()                                 <span style=color:green>// id: %6</span>
} <span style=color:green>// end sil function &#39;$s4main7MyClassCAA0B8ProtocolA2aDP8myMethodyyFTW&#39;</span>

sil_vtable MyClass {
  #MyClass.myMethod: (MyClass) -&gt; () -&gt; () : @<span>$</span>s4main7MyClassC8myMethodyyF	<span style=color:green>// MyClass.myMethod()</span>
  <span style=color:green>// 省略无关代码...</span>
}

sil_witness_table hidden MyClass: MyProtocol module main {
  method #MyProtocol.myMethod: &lt;<span style=color:#00f>Self</span> <span style=color:#00f>where</span> <span style=color:#00f>Self</span> : MyProtocol&gt; (<span style=color:#00f>Self</span>) -&gt; () -&gt; () : @<span>$</span>s4main7MyClassCAA0B8ProtocolA2aDP8myMethodyyFTW	<span style=color:green>// protocol witness for MyProtocol.myMethod() in conformance MyClass</span>
}
</code></pre></div><p>我们可以看到 <code>myMethod</code> 出现在了 <code>sil_witness_table</code> 中，调用时用 <code>witness_method</code> 指令，所以 protocol 中的方法也采用动态派发。此外，我们通过 <code>MyProtocol.myMethod</code> 的具体实现 <code>@$s4main7MyClassCAA0B8ProtocolA2aDP8myMethodyyFTW</code> 可以看到，其内部还是调用了 <code>MyClass.myMethod</code> 方法。</p><p>通过上述分析我们可以得出结论：值类型的函数采用静态派发，引用类型的函数采用动态派发(class 采用 <code>vtable</code>，protocol 采用 <code>witness_table</code>)。</p><h3 id=32-声明位置>3.2 声明位置</h3><p>函数声明位置的不同使用的派发方式也可能不相同，我们接着3.1中的分析继续验证在各个数据结构的扩展中声明的函数派发方式</p><h4 id=值类型-1>值类型</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#00f>struct</span> <span style=color:#2b91af>MyStruct</span> {}

<span style=color:#00f>extension</span> <span style=color:#2b91af>MyStruct</span> {
    <span style=color:#00f>func</span> myMethod() {}
}

<span style=color:#00f>let</span> myStruct = MyStruct()
myStruct.myMethod()
</code></pre></div><p>转换成 SIL 后函数调用部分代码</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// function_ref MyStruct.myMethod()</span>
%9 = function_ref @<span>$</span>s4main8MyStructV8myMethodyyF : <span>$</span>@convention(method) (MyStruct) -&gt; () <span style=color:green>// user: %10</span>
%10 = apply %9(%8) : <span>$</span>@convention(method) (MyStruct) -&gt; ()
</code></pre></div><p>我们看到对于 struct 来说，在 extension 中声明的函数并不会改变派发方式，依然采用静态派发。同理我们可验证在 enum extension 中依然采用静态派发。</p><h4 id=引用类型-1>引用类型</h4><p>将函数声明放在 class extension 中的 SIL 代码如下</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// main</span>
sil @main : <span>$</span>@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {
bb0(%0 : <span>$</span>Int32, %1 : <span>$</span>UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):
  <span style=color:green>// 省略无关代码...</span>
  <span style=color:green>// function_ref MyClass.myMethod()</span>
  %9 = function_ref @<span>$</span>s4main7MyClassC8myMethodyyF : <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; () <span style=color:green>// user: %10</span>
  %10 = apply %9(%8) : <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; ()
  <span style=color:green>// 省略无关代码...</span>
} <span style=color:green>// end sil function &#39;main&#39;</span>

sil_vtable MyClass {
  #MyClass.<span style=color:#00f>init</span>!allocator: (MyClass.<span style=color:#00f>Type</span>) -&gt; () -&gt; MyClass : @<span>$</span>s4main7MyClassCACycfC	<span style=color:green>// MyClass.__allocating_init()</span>
  #MyClass.<span style=color:#00f>deinit</span>!deallocator: @<span>$</span>s4main7MyClassCfD	<span style=color:green>// MyClass.__deallocating_deinit</span>
}
</code></pre></div><p>我们可以看到，MyClass 的 <code>vtable</code> 中已经没有了 <code>myMethod</code> 方法。同时，调用 <code>myMethod</code> 时采用了静态派发的方式，这说明 class extension 中方法的派发方式为静态派发。</p><h4 id=协议-1>协议</h4><p>我们将函数的声明位置放到 protocol extension 中，生成的 SIL如下</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// main</span>
sil [ossa] @main : <span>$</span>@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {
bb0(%0 : <span>$</span>Int32, %1 : <span>$</span>UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):
  <span style=color:green>// 省略无关代码...</span>
  <span style=color:green>// function_ref MyProtocol.myMethod()</span>
  %10 = function_ref @<span>$</span>s4main10MyProtocolPAAE8myMethodyyF : <span>$</span>@convention(method) &lt;<span>τ</span>_0_0 <span style=color:#00f>where</span> <span>τ</span>_0_0 : MyProtocol&gt; (@in_guaranteed <span>τ</span>_0_0) -&gt; () <span style=color:green>// user: %11</span>
  %11 = apply %10&lt;@opened(<span style=color:#a31515>&#34;0BF36FCA-E38C-11EB-96BB-ACDE48001122&#34;</span>) MyProtocol&gt;(%9) : <span>$</span>@convention(method) &lt;<span>τ</span>_0_0 <span style=color:#00f>where</span> <span>τ</span>_0_0 : MyProtocol&gt; (@in_guaranteed <span>τ</span>_0_0) -&gt; () <span style=color:green>// type-defs: %9</span>
  <span style=color:green>// 省略无关代码...</span>
} <span style=color:green>// end sil function &#39;main&#39;</span>

<span style=color:green>// ...</span>
<span style=color:green>// 省略无关代码...</span>
<span style=color:green>// ...</span>

sil_witness_table hidden MyClass: MyProtocol module main {
}
</code></pre></div><p>我们可以看到 <code>sil_witness_table</code> 中并没有 <code>myMethod</code> 方法，且调用时直接代用静态派发。</p><p>通过以上分析我们可以得出结论：值类型、引用类型和协议三者的扩展中声明的方法采用静态派发。</p><h3 id=33-指定派发方式>3.3 指定派发方式</h3><p>我们只讨论会改变其原本派发方式的关键字</p><h4 id=final><code>final</code></h4><p><code>final</code> 是用于 classes 或者 class members 前的关键字，用来防止被重写，当类的函数使用 <code>final</code> 关键字修饰后，生成的 SIL</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// main</span>
sil [ossa] @main : <span>$</span>@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {
bb0(%0 : <span>$</span>Int32, %1 : <span>$</span>UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):
  <span style=color:green>// 省略无关代码...</span>
  <span style=color:green>// function_ref MyClass.myMethod()</span>
  %9 = function_ref @<span>$</span>s4main7MyClassC8myMethodyyF : <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; () <span style=color:green>// user: %10</span>
  %10 = apply %9(%8) : <span>$</span>@convention(method) (@guaranteed MyClass) -&gt; ()
  <span style=color:green>// 省略无关代码...</span>
} <span style=color:green>// end sil function &#39;main&#39;</span>

<span style=color:green>// ...</span>
<span style=color:green>// 省略无关代码...</span>
<span style=color:green>// ...</span>

sil_vtable MyClass {
  #MyClass.<span style=color:#00f>init</span>!allocator: (MyClass.<span style=color:#00f>Type</span>) -&gt; () -&gt; MyClass : @<span>$</span>s4main7MyClassCACycfC	<span style=color:green>// MyClass.__allocating_init()</span>
  #MyClass.<span style=color:#00f>deinit</span>!deallocator: @<span>$</span>s4main7MyClassCfD	<span style=color:green>// MyClass.__deallocating_deinit</span>
}
</code></pre></div><p>可以看出函数的派发方式变成了静态派发，而且 <code>sil_vtable</code> 中已没有了 <code>myMethod</code> 方法。同样的，用 <code>final</code> 关键字修饰 class 后，自定义的函数同样会被自动定义为 <code>final</code>，所以派发方式也为静态派发。</p><h4 id=static><code>static</code></h4><p>通过在方法的 <code>func</code> 关键字前写上 <code>static</code> 关键字来表示类型方法，Swift 中的所有类型(结构体、枚举、类、协议)都可以定义类型方法。</p><p>struct、struct extension、enum、enum extension、class、class extension、protocol、protocol extension 等类型中的方法用 <code>static</code> 修饰后都采用静态派发方式，这里不做验证，有兴趣可自行转换成 SIL 查看。</p><h4 id=class><code>class</code></h4><p>在 Swift 类中声明类型方法时 <code>static</code> 关键字可用 <code>class</code> 来代替，并且如果没有 <code>final</code> 修饰的话，允许子类覆盖父类对该方法的实现。对应的 SIL 为</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:green>// main</span>
sil [ossa] @main : <span>$</span>@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {
bb0(%0 : <span>$</span>Int32, %1 : <span>$</span>UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):
  <span style=color:green>// 省略无关代码...</span>
  %3 = class_method %2 : <span>$</span>@thick MyClass.<span style=color:#00f>Type</span>, #MyClass.myMethod : (MyClass.<span style=color:#00f>Type</span>) -&gt; () -&gt; (), <span>$</span>@convention(method) (@thick MyClass.<span style=color:#00f>Type</span>) -&gt; () <span style=color:green>// user: %4</span>
  %4 = apply %3(%2) : <span>$</span>@convention(method) (@thick MyClass.<span style=color:#00f>Type</span>) -&gt; ()
  <span style=color:green>// 省略无关代码...</span>
} <span style=color:green>// end sil function &#39;main&#39;</span>

<span style=color:green>//</span>
<span style=color:green>// 省略无关代码...</span>
<span style=color:green>//</span>

sil_vtable MyClass {
  #MyClass.myMethod: (MyClass.<span style=color:#00f>Type</span>) -&gt; () -&gt; () : @<span>$</span>s4main7MyClassC8myMethodyyFZ	<span style=color:green>// static MyClass.myMethod()</span>
  #MyClass.<span style=color:#00f>init</span>!allocator: (MyClass.<span style=color:#00f>Type</span>) -&gt; () -&gt; MyClass : @<span>$</span>s4main7MyClassCACycfC	<span style=color:green>// MyClass.__allocating_init()</span>
  #MyClass.<span style=color:#00f>deinit</span>!deallocator: @<span>$</span>s4main7MyClassCfD	<span style=color:green>// MyClass.__deallocating_deinit</span>
}
</code></pre></div><p>我们可以看到，用 <code>class</code> 来修饰的类方法出现在了 <code>sil_vtable</code> 中，且采用的是动态派发。此外，在类的扩展中的方法用 <code>class</code> 修饰后依然采用静态派发，且子类不可重写(子类重写会得到一个编译时错误)。</p><h4 id=objc><code>@objc</code></h4><p>class extension 中的方法用 <code>@objc</code> 标记后派发方式改为了消息派发。至于原因，目前还没有找到相关的文档说明</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>%9 = objc_method %8 : <span>$</span>MyClass, #MyClass.myMethod!foreign : (MyClass) -&gt; () -&gt; (), <span>$</span>@convention(objc_method) (MyClass) -&gt; () <span style=color:green>// user: %10</span>
%10 = apply %9(%8) : <span>$</span>@convention(objc_method) (MyClass) -&gt; ()
</code></pre></div><h4 id=objc-dynamic><code>@objc dynamic</code></h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>%9 = objc_method %8 : <span>$</span>MyClass, #MyClass.myMethod!foreign : (MyClass) -&gt; () -&gt; (), <span>$</span>@convention(objc_method) (MyClass) -&gt; () <span style=color:green>// user: %10</span>
%10 = apply %9(%8) : <span>$</span>@convention(objc_method) (MyClass) -&gt; ()
</code></pre></div><p>class 或者 class extension 中的方法被标记为 <code>@objc dynamic</code> 会变成消息派发</p><h3 id=34-编译器优化>3.4 编译器优化</h3><h4 id=尽量直接派发>尽量直接派发</h4><p>Swift 编译器会尽可能的将派发方式优化为直接派发。</p><h4 id=内联优化>内联优化</h4><p>Swift 编译器会对一些方法的派发方式进行内联优化，具体做法是将方法的具体实现放入调用函数的位置，去除了函数具体实现的指针调用步骤，提供运行效率。</p><h2 id=4-效率对比>4. 效率对比</h2><p>我们来对比一下 Swift 中各种方法调度所耗费的时间</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#00f>protocol</span> <span style=color:#2b91af>TestProtocol</span> {
    <span style=color:#00f>func</span> witnessTableDispatch()
}

<span style=color:#00f>struct</span> <span style=color:#2b91af>TestStruct</span> {
    <span style=color:#00f>func</span> staticDispatch() {}
}

<span style=color:#00f>class</span> <span style=color:#2b91af>TestClass</span>: TestProtocol {
    <span style=color:#00f>final</span> <span style=color:#00f>func</span> staticDispatch() {}
    <span style=color:#00f>func</span> vTableDispatch() {}
    <span style=color:#00f>func</span> witnessTableDispatch() {}
    <span style=color:#00f>@objc</span> <span style=color:#00f>dynamic</span> <span style=color:#00f>func</span> messageDispatch() {}
}

<span style=color:#00f>var</span> testStruct = TestStruct()
<span style=color:#00f>var</span> testClass = TestClass()

<span style=color:#00f>var</span> startDate = Date()
<span style=color:#00f>var</span> maxTimes = Int(1e7)

(1...maxTimes).forEach { <span style=color:#00f>_</span> <span style=color:#00f>in</span> testStruct.staticDispatch() }
print(<span style=color:#a31515>&#34;static dispatch in struct duration: </span><span style=color:#a31515>\(</span>Date<span style=color:#a31515>()</span>.timeIntervalSince<span style=color:#a31515>(</span>startDate<span style=color:#a31515>))</span><span style=color:#a31515>&#34;</span>)

startDate = Date()
(1...maxTimes).forEach { <span style=color:#00f>_</span> <span style=color:#00f>in</span> testClass.staticDispatch() }
print(<span style=color:#a31515>&#34;static dispatch in class duration: </span><span style=color:#a31515>\(</span>Date<span style=color:#a31515>()</span>.timeIntervalSince<span style=color:#a31515>(</span>startDate<span style=color:#a31515>))</span><span style=color:#a31515>&#34;</span>)

startDate = Date()
(1...maxTimes).forEach { <span style=color:#00f>_</span> <span style=color:#00f>in</span> testClass.vTableDispatch() }
print(<span style=color:#a31515>&#34;vtable dispatch duration: </span><span style=color:#a31515>\(</span>Date<span style=color:#a31515>()</span>.timeIntervalSince<span style=color:#a31515>(</span>startDate<span style=color:#a31515>))</span><span style=color:#a31515>&#34;</span>)

startDate = Date()
(1...maxTimes).forEach { <span style=color:#00f>_</span> <span style=color:#00f>in</span> testClass.witnessTableDispatch() }
print(<span style=color:#a31515>&#34;witness_table dispatch duration: </span><span style=color:#a31515>\(</span>Date<span style=color:#a31515>()</span>.timeIntervalSince<span style=color:#a31515>(</span>startDate<span style=color:#a31515>))</span><span style=color:#a31515>&#34;</span>)

startDate = Date()
(1...maxTimes).forEach { <span style=color:#00f>_</span> <span style=color:#00f>in</span> testClass.messageDispatch() }
print(<span style=color:#a31515>&#34;objc_message dispatch duration: </span><span style=color:#a31515>\(</span>Date<span style=color:#a31515>()</span>.timeIntervalSince<span style=color:#a31515>(</span>startDate<span style=color:#a31515>))</span><span style=color:#a31515>&#34;</span>)
</code></pre></div><p>经过多次运行，输出结果</p><p><img src=/images/swift_dispatch_performance.png alt=swift_dispatch_performance></p><p>我们可以发现，struct 中的静态派发要比 class 中的快，而 class 中的静态派发、vtable 派发 和 witness_table 派发耗时基本相同，objc_message 派发最慢。从而我们可以得出 Swift 中派发方式执行效率排名：</p><p>静态派发 > 函数派发 > 消息派发</p><h2 id=总结>总结</h2><p>Swift 中支持静态派发和动态派发的方式，而且实现动态派发的方式还不止一种(<code>vtable</code>、<code>witness_table</code>、<code>objc_message</code>)。数据类型、方法声明位置、方法关键字的不同，使用的派发方式也不同。汇总在一起可以得出如下表格：</p><p><img src=/images/swift_dispatch_table.svg alt=swift_dispatch_table></p><p>不同派发方式的执行效率也不同。此外，Swift 编译器还会优化编译方式，甚至会使用内联优化，从而使代码执行效率更高。</p><p>而至于为什么效率对比中的输出结果中显示，结构体中的静态派发和类中的静态派发时间不一致？类中的静态派发时间和函数表派发时间差不多甚至还要更多一点？我们以后再探索。</p></div><div class=tags></div><div id=disqus_thread></div><script type=text/javascript>(function(){var a,b;if(window.location.hostname=="localhost")return;a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='ink-demo',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)})()</script><noscript>Please enable JavaScript to view the</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><div class="footer wrapper"><nav class=nav><div>2021 © Leon. | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123-45','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>